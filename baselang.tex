\secrel{Основные инструменты и основы языка}\secdown

\secly{Alan Kay про язык \st}

Возможно, именно коммерциализация в 1980х годах убила следующую новую вещь, которую мы ожидали увидеть.
Наш план и наша надежда состояли в том, что следующее поколение детей придет и сделает что-то лучше, 
чем \st\ который мы им предлагали, где-нибудь в 1984 году или около того.
Мы все думали, что следующее поколение языка программирования будет гораздо более стратегическим и 
даже ориентированным на социум, и будет гораздо больше знаний о том, что нужно с ним делать.
Но множество разных обстоятельств сошлись вместе, и это следующее поколение средств программирования фактически не появилось.
На самом деле можно утверждать\ --- как я это иногда делаю\ --- что коммерческий успех
персональных компьютеров и операционных систем на самом деле привел к значительной регрессии во многих, многих отношениях.

Вы можете думать об этом как о применении фильтра низких частот к идеям 60/70-х годов,
который пропускает только слабые концепции, поскольку компьютерные технологии распространяются
намного быстрее, чем обучение неопытных людей.
За последние 30 лет или около того мы получили нечто похожее на поп-культуру, 
это похоже на то, что произошло, когда на сцену вышло телевидение, и некоторые из его 
изобретателей думали, что это будет способ донести Шекспира до широких масс.
Но они забыли, что публика должна быть более подготовлена и иметь большую перспективу мышления, чтобы понять Шекспира.
Что телевидение могло сделать, так это захватить людей такими, какие они есть.

Таким образом, я думаю, что отсутствие настоящего computer science, и отсутствие 
настоящей разработки программного обеспечения сегодня отчасти связаны с подобной поп-культурой.
Если вы посмотрите на программное обеспечение сегодня, сквозь призму истории инженерии, 
оно, безусловно, тоже является продуктом инжиниринга, но это тот тип разработки,
который люди сделали без концепции и архитектуры.
Большая часть программного обеспечения сегодня очень похожа на египетскую пирамиду
с миллионами кирпичей, сложенных друг на друга, без структурной целостности,
но сделанных грубой силой и тысячами рабов.

Я бы сравнил то что мы делали со Smalltalk в 70х, с чем-то вроде готического собора.
У нас было две идеи, правда. Одну из них мы взяли от Lisp: \term{позднее связывание}.
Другой была идея \term{объектов}. Это дало нам что-то немного похожее на архитектуру, 
поэтому мы могли сделать сложные, казалось бы, большие конструкции из очень 
небольшого количества материала, но я не могу сказать что мы далеко 
ушли от инженерных разработок 1000 лет назад.

Если вы посмотрите на \href{https://www.youtube.com/watch?v=yJDv-zdhzMY}{презентацию Энгельбарта}, 
представленную на Осенней совместной компьютерной конференции в 1968 году, 
то вы увидите много идей о том, как повысить коллективный IQ группы и помочь 
им работать вместе, больше чем вы видите в коммерческих системах сегодня.
Я думаю, что существует очень длительный разрыв между тем, что вы могли бы назвать 
лучшей практикой в компьютерных исследованиях на протяжении многих лет, и тем, 
что может просочиться и адаптироваться в гораздо более целесообразном 
и ориентированном на конечный результат внешнем мире.

Дело не в том, что люди совершенно глупы, но если есть большая идея, 
а у вас есть сроки, у вас есть целесообразность, и у вас есть конкуренты, 
очень вероятно, что вы будете использовать ограничивающий фильтр для этой идеи\ ---
реализуете только ее часть, и выкинете то что должно быть сделано дальше.
Это происходит снова и снова. Если вы используете языки с ранним связыванием, 
как это делают большинство людей, вместо языков позднего связывания, 
то вы действительно блокируетесь на том, что уже сделали.
Вы не можете переформулировать вещи так легко.

Надо сказать, что принятие языков программирования очень часто было несколько 
случайным, и акцент очень часто делался на том, насколько легко реализовать 
язык программирования, а не на его реальных достоинствах и особенностях.
Например, Васик никогда бы не всплыл, потому что для этих целей всегда был язык лучше.
Этим языком был Joss, который предшествовал Basic и был прекрасен.
Но Basic оказался в системе разделения времени General Electric, 
которая была создана в Дартмуте, и когда GE решила предоставить франшизу, 
она начала распространять Basic только потому, что он там уже был, 
а не потому, что имел какие-либо внутренние достоинства.

Это происходит снова и снова.
Языки Никлауса Вирта распространились дико и широко, потому что он был одним 
из самых добросовестных документаторов языков и одним из первых, кто делал 
алгоритмические языки с использованием p-кодов (псевдокодов)\ --- тот же 
принцип, которые использовали мы.
Идея использования этой штуки (байт-кода) имеет общее происхождение от аппаратной 
части машины под названием Burroughs B5000 с начала 1960х годов, которую истеблишмент ненавидел.
Почти все в этой машине было совершенно другим, и то, чего она пыталась достичь, было совершенно другим.
По этой машине было огромное количество доступной информации.
Проблема заключалась в том, что менеджеры дата-центров не хотели изучать новые способы вычисления или даже вычисления вообще.
IBM поняла это, а Берроуз\ --- нет.
Ни Intel, ни Motorola, ни какая-либо другая компания, занимающаяся 
производством микросхем, не поняли, почему эта архитектура была хорошей идеей.
Могу дать вам интересный пример\ --- тест производительности 1979 года для Xerox PARC, 
сделанной в некоторым смысле по идеям B5000, на похожей по назначению 
современной машине работает всего в 50 раз быстрее.
Закон Мура дал нам улучшение скорости железа в 40–60 тысяч раз за это время. 
Таким образом, эффективность из-за плохой архитектуры процессоров снизилась примерно в 1000 раз.

Вообще, я не трачу время на жалобы на эти вещи, потому что то, что произошло за 
последние 20 лет, вполне нормально, хотя это и было неудачно.
Если у вас есть что-то, что растет быстрее, чем растет образование, вы всегда получите поп-культуру.
Хорошо известно, что я пытался убить \st\ в конце 70х.
Было несколько лет, когда это была самая замечательная вещь в мире.
Он отвечал потребностям и при этом был более компактным и красивым, чем все, что было сделано раньше.
Но время идет.
Когда мы узнали больше и стали более амбициозными в отношении того, что мы хотим сделать, 
мы поняли, что в \st\ есть все виды вещей, которые не масштабируются так, как они должны\ --- например
рефлексия. Это был один из первых языков, который действительно мог исследовать сам себя, 
но теперь стало известно, как сделать все уровни рефлексии намного лучше\ --- поэтому мы должны были это реализовать.
Объектную модель можно было бы сделать намного лучше и т.д.

Я имею в виду, что и Lisp, и \st\ --- действительно потрясающие средства, потому что у них есть свойства мета-системы.
У них так много способов справиться с проблемами, и этих способов нет в языках раннего связывания, 
поэтому людям, которые любят Lisp или \st, очень и очень трудно представить что-либо еще.
Теперь просто вспомним пару вещей о \java: у нее действительно нет полной мета-системы.
У нее есть элементы, которые не являются объектами, и есть вещи, которые они называют объектами.
Она действительно имеет кучу проблем пытаясь работать в динамике.
Главное\ --- технология \java\ не так хороша, поскольку не применима сама к себе.
В течение многих лет комплекты для разработки на \java\ делались на \cpp. Это показательная вещь.

Мы очень внимательно изучили \java\ в 1995 году, когда мы начинали с основного набора реализаций,
просто потому, что работа над жизнеспособным языковым ядром\ --- это большая работа.
В \java\ нам меньше всего нравился способ ее реализации.
У нее была старая идея, которая никогда не работала: иметь набор бумажных спецификаций, 
необходимость реализации виртуальной машины по этим спецификациям, а затем гонять тесты, 
которые пытаются проверить то, что вы только что реализовали\ --- и это никогда не приводило 
к полностью совместимой системе.

Техника, которая у нас была для \st, заключалась в том, чтобы написать модель виртуальной машины
на самой себе, поэтому существует \st-симулятор ВМ, который по сути является ее единственной спецификацией.
Вы можете отлаживать и отвечать на любые вопросы о том, что будет делать ВМ, 
отправляя в нее исходные данные, и вы делаете любые изменения виртуальной машины, которые вы хотите,
просто изменяя ее симулятор.
После того, как вы все отладили все так, как хотели, вы нажимаете на кнопку, 
и система без вмешательства человека генерирует математически правильную версию на \ci, 
которая будет работать на любой платформе, на которую вы пытаетесь попасть.

В результате сегодня эта система Squeak одинаково работает на более чем двух десятках платформ.
\java\ так не может. Если вы думаете о том, что означает Интернет, это означает, 
что вы должны работать одинаково на всем, что к нему подключено.
Так что Java по моему всегда нарушала одну из главных вещей в разработке 
программного обеспечения для мира Интернета.
Как только мы поняли, что \java, вероятно, не может быть полностью совместима от 
платформы к платформе, мы просто сказали, что создадим нашу собственную систему, 
абсолютно переносимую, и именно это мы и сделали.
Любой может сделать это. Если бы у профессионалов в Sun была возможность исправить \java,
мир стал бы чуть более удобным. Это не секретное знание. Это просто секрет этой поп-культуры.

Вообще говоря, Лисп был тщательно определен в терминах Лиспа.
Это было большим открытием для меня, когда я учился в аспирантуре\ --- я внезапно понял, 
что полстраницы кода в нижней части 13й страницы руководства по Lisp 1.5 это сам по себе Lisp.
Это были «уравнения Максвелла» для программного обеспечения! Весь мир программирования 
состоит из нескольких строк, которые я могу накрыть одной рукой.
Я понял, что всякий раз, когда я хочу знать, что я делаю, я могу просто записать 
ядро этой вещи на полстраницы, и она не потеряет никакой силы.
Фактически, она наоборот получит мощь, будучи способной выразить себя гораздо легче, 
чем большинство систем, сделанных другим способом.

Все эти идеи могут быть частью как программной инженерии, так и информатики, но я боюсь, 
насколько я могу судить, что большинство вузовских курсов в области компьютерных наук 
в настоящее время\ --- это в основном профессиональное обучение \java.
Я слышал жалобы даже от могущественного Стэнфордского университета с его выдающимся 
преподавательским составом на то, что программа бакалавриата в области компьютерных 
наук\ --- это чуть больше, чем сертификация \java.

Вы должны быть особенным человеком, чтобы любить \cpp. 
Это действительно интересный пример того, как добрая идея пошла побоку, потому что 
Бьярн Страуструп не пытался окончательно сделать то, за что его критикуют.
Его идея заключалась в том, что было бы полезно сделать из Си то, что Simula 
сделала с Algol, который в основном выступает в качестве препроцессора для 
совершенно другого типа архитектурного шаблона программирования.
Это было в основном для супер-хороших программистов, которые должны были поделить 
все на подклассы, включая распределение памяти, прежде чем они сделали бы что-то серьезное.
Результатом, конечно, было то, что большинство программистов недостаточно обмазались классами.
Так что люди, которых я знаю, которые любят \cpp\ и добились в его использовании
хороших результатов, были серьезными железными людьми, которые в основном приняли 
это за то, чем это должно было быть, что-то вроде макропроцессора.
Я вырос на макросистемах в начале 60х, и отлично знаю что вам нужно проделать большую 
работу, чтобы заставить их работать на вас, иначе они вас убьют.
Собственно, \cpp\ и был запрограммирован как макропроцессор, так же как и Симула.

В истории \st, которую я написал для ACM, я охарактеризовал один из способов взглянуть 
на языки таким образом: многие из них являются либо слепком фичей, либо кристаллизацией стиля.
Такие языки, как APL, Lisp и Smalltalk, --- это то, что можно назвать языками стилей,
где реальным ядром является стиль того, как вы должны все делать.
Другие языки пытаются объединять без консолидации, и часто оказываются более успешными.
Я думаю, что языки стиля нравятся людям, которые имеют некоторую математическую лень по отношению к ним.
Такая лень на самом деле окупается позже, потому что если вы потратите немного больше 
времени на то, чтобы увидеть: «О, да, этот язык позволит мне сделать это действительно 
очень красиво и в более общем смысле, чем я мог бы сделать как обычно», 
то обычно это возвращается в виде помощи вам, когда у вас появилась новая идея через год.
Склеивающие языки, с другой стороны, имеют тенденцию вызывать залипание, 
и из них очень трудно выпутаться, когда у вас появилась эта новая идея.

Кроме того, я думаю, что языки стиля, как правило, являются языками позднего связывания, а склеивающие\ --- обычно раннего.
Это имеет огромное влияние на весь подход.
Типы ошибок, с которыми вам приходится иметь дело, и то когда вам приходится иметь с ними дело, совершенно отличаются.
Некоторые люди абсолютно религиозны в отношении систем типов, и как математику, мне нравится идея систем типов, 
но никто никогда не придумал такую систему, которая имела бы достаточное покрытие. 
Если объединить типизацию Simula и рефлексивность Lisp\ --- получиться динамическая система типов, 
которая даст вам необходимый диапазон выразительности.
Это позволит вам думать в том типе мыслей, в котором вам нужно думать, не беспокоясь о том, 
что это за тип, потому что у вас есть гораздо более широкий спектр проблемных вещей.
Вы платите за некоторые проверки, которые будут выполнены во время выполнения, 
и, особенно в старые времена, вы платили за это эффективностью.
Теперь мы разберемся с эффективностью так же, как Бартон с B5000: просто сказав: 
«Забудьте, мы собираемся выполнить эту важную вещь настолько прямо, насколько это возможно».
Мы не будем беспокоиться о том, сможем ли мы скомпилировать его на компьютер фон-Неймана или нет, 
мы заставим микрокод делать то, что нам нужно, чтобы обойти эту неэффективность, потому 
что многие неэффективности\ --- это просто использование устаревших аппаратных архитектур.

Я просто думаю, что это разделение двух культур. Я видел много совещаний, 
где люди не могли общаться только из-за стилистических различий в подходах.

Что касается изменений в \st\ в течение его развития, хорошая вещь заключалась в том, 
что его концепция никогда не была разбавлена, при том что объем практических вещей, 
которые вы могли делать в \st, значительно расширился за период в Xerox PARC.

Первоначально язык задумывался для детей, но по сути получилось так, что это 
транспортное средство становилось все более и более средством для программистов,
и все менее велосипедом для детей. Выпущенная версия \st'80, я не думаю, 
что она когда-либо могла быть запрограммирована ребенком. 
Я не думаю, что ребенок мог запрограммировать его, потому что \st\ потерял
некоторые из своих удобств, даже когда приобрел прагматическую силу.

Таким образом, смерть \st\ в некотором роде наступила, как только он был 
признан настоящими программистами как нечто полезное; они превратили его 
в свой собственное отображение, и он начал терять свои прекрасные 
возможности для конечных пользователей.

Но это нормально. Этот проект, который мы начали в 1995 году, чтобы сделать Squeak 
средством реализации другой системы (eToys) предназначенной для детей.
Это было сделано довольно хорошо и используется многими по всему миру.
Другой способ взглянуть на это\ --- понять, что компьютеры были созданы для программирования людьми.
Давайте свернем эту тему, и не будем жаловаться на \java\ или даже на \st.

\vspace{1cm}\noindent
слишком вольный перевод
интервью Алана Кея, одного из авторов языка \st\\
\url{https://queue.acm.org/detail.cfm?id=1039523}

\clearpage
\secrel{Playground: командная консоль}\label{playground}

\fig{img/playground.png}{height=.5\textheight}

\medskip
\noindent\menu{World>Toold>Playgroun} или \keys{Ctrl+O+W}\\
Рабочее окно, в котором могут быть введены, отредактированы и выполнены произвольные фрагменты \st-кода.
Управление системой через код как команды, определение переменных для хранения структур данных, с которыми вы работаете.
После выделения куска кода нажать правую кнопку мыши \keys{\rms}, повится контекстное меню с доступными операциями.

\medskip\noindent

\fig{img/2p3.png}{width=.55\textwidth}

\fig{img/plmenu.png}{width=.57\textwidth}

\begin{description}
    \item{Do it} \keys{Ctrl+D} выполнить выделенный код
    \item{Print it} \keys{Ctrl+P} вычислить выражение и вывести результат под курсор
    \item{Inspect it} \keys{Ctrl+I} инспектор \ref{inspect}
\end{description}

\secrel{Inspect: просмотр объекта}\label{inspect}

\fig{img/inspect.png}{height=.5\textheight}

Просмотр и взаимодействие с конкретным объектом. Окно состоит из двух частей:
\begin{itemize}
    \item просмотр полей объекта: значения переменных
    \item нижняя часть\ --- интерактивный редактор кода аналогичный \ref{playground}
\end{itemize}

\input{browser}

\secrel{Monticello: управление репозиториями}

\secup
