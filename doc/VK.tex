\url{https://vk.com/topic-190100763_40901648}

\secly{почему умер Smalltalk и что может его возродить?}

Идеология Smalltalk — пользователю предоставляется полный доступ ко всем внутренностям системы, вы можете не только просмотреть исходный код любой системной компоненты до уровня байт-кода, но и внести в них собственные изменения на ходу, не прерывая работы системы и программ в ее составе. Возможности интерактивной отладки уникальны для Smalltalk, ни в одном другом языке вы не можете изменять исходный код, перекомпилировать и подменять части вашей программы на ходу, в рантайме, не останавливая работу программы.

С другой стороны, Smalltalk это штука специфическая — это скорее не язык программирования, и не IDE, а гостевая ОС, работающая поверх другой платформы, со своим языком, архитектурой, и именно этим объясняется ее изолированность, и определенные проблемы интеграции с другими языками программирования и сервисами хост-системы.

Вероятно, закат языка Smalltalk в конце 90х - начале 2000х годов связан не только с его заменой на Java в сегменте корпоративных систем, и проигрышу по производительности по сравнению с С++, но и неправильным применением?

\clearpage

В интервью с Alan Kay https://queue.acm.org/detail.cfm?id=1039523 есть интересная мысль: не нужно гнаться за mainstream, потому что mainstream может воспринимать только "слабые" идеи, и фильтрует "сильные". Более того, не система программирования должна следовать за аппаратной архитектурой компьютера, а наоборот — берите "сильную" идею, используйте ее как свое секретное оружие, и "железо" последует за вами в случае глобального успеха (в случае FPGA — вы сами можете контролировать свое железо).

Можно посмотреть на этот принцип чуть шире. Наш заказчик или работодатель требует чтобы мы разрабатывали программные (и аппаратные) системы только с использованием mainstream инструментов и языков, чтобы обеспечить поддержку кода, совместимость с коллегами, совместимость с типовыми инструментами. Чаще всего допустимый стек технологий задан жестко и однозначно, не важно что это — 1С, Java/Spring, JS/Node, embedded C для одного единственно допустимого компилятора, или что-то еще.

Мы бы хотели наоборот использовать удобные или интересные для нас самих инструменты и языки.

https://ru.wikipedia.org/wiki/Гомоиконичность

Мы можем добавить еще один слой косвенности — работать с программой на любом языке программирования как со структурой данных. Можно заменить исходный код в текстовых файлах на исполняемую структур данных (EDS), которая является представлением программы. Работать с такой структурой мы можем на любом другом удобном для нас языке — Smalltalk, Haskell, Python, Picat,..

Фактически, мы можем программировать на Smalltalk на любом языке — в любой момент EDS-структура или ее часть может быть выгружена из среды разработки как набор ASCII файлов на диск, и синхронизирована с Git, Visual Studio, скомпилирована и загружена в виде прошивки в железку, запущена в отладчике и т.п. И одновременно мы имеем полный доступ к этой структуре, и можем не только ее преобразовывать, но и исполнять и отлаживать через интерпретацию.

\clearpage

Одновременно с тем, как мы освобождаемся от необходимости писать на конкретном языке программирования/стеке, отпадает и необходимость тащить кучу проблем со стороны самого Smalltalk. Нам не нужно связываться со чужими нестабильными библиотеками, которые оказываются несовместимыми с нашей системой, или периодически падают с неясными ошибками. Не нужно решать проблемы FFI или наличия виртуальной машины для специфического железа, или Android, QNX,.. — достаточно, чтобы на вашей рабочей станции запускалась любая Smalltalk-система, с которой вам удобно работать. Если ваша любимая система не работает под текущей ОС (Dolphin, Cincom), ее можно запустить в эмуляторе, прокинуть файловую систему и сеть — и можно продолжать работу в привычной среде.

Нет проблем совместимости компилятора Си, динамических библиотек, ограничений FFI, кривой многозадачности, стыковки с внешними системами, биндинга LLVM,... Все что требуется — чтобы Smalltalk умел работать с файловой системой, с текстовым буфером обмена, и по вкусу с сетью и запуском внешних процессов (утилиты, компилятор, отладчик, обмен данными с вашей целевой программой).

\clearpage

https://ru.wikipedia.org/wiki/Метапрограммирование

Метапрограммирование — программы, которые пишут программы.

Это вид программирования, связанный с созданием программ, которые порождают другие программы как результат своей работы, либо программ которые меняют себя во время выполнения (самомодифицирующийся код). Первое позволяет получать программы при меньших затратах времени и усилий, чем если бы программист писал их вручную целиком, второе позволяет улучшить свойства кода (размер и быстродействие).

Представление целевой программы в виде структуры данных, и разработка через ее трансформацию, интерпретацию и транспиляцию в исходный код дает большую свободу по использованию произвольной модели программирования — вы можете использовать любую концепцию или парадигму для описания требуемой работы программы, пока вы способны реализовать интерпретацию и трансляцию модели на Smalltalk.

В определенном смысле это MDD не завязанная на мозголомные стандарты и недоделки OMG: https://ru.wikipedia.org/wiki/Разработка,_управляемая..
Вы совершенно свободны в выборе моделей, пока вы способны трансформировать их в исходный код.

\clearpage

Какой тип EDS-структуры выбрать? Какой хотите.

Мне нравится концепция фреймов Марвина Мински https://e-libra.ru/read/331636-frejmi-dlya-predstavle.. расширенная возможностью хранить во фрейме ссылки на другие фреймы упорядоченно, а не только по именам.

\url{https://neerc.ifmo.ru/wiki/index.php?title=Атрибутные_грамматики}

Ну т.е. используя направленный (гипер)граф из расширенных фреймов Мински, мы переходим к универсальному представлению знаний, включая структуры, давно, широко и традиционно используемые в реализации языков программирования — AST-деревья и атрибутные грамматики.

Каждый узел — базовый фрейм, или любой наследованный от него класс данных:

\begin{verbatim}
Object subclass: #MFrame
    instanceVariableNames: 'val slot nest'
    classVariableNames: 'type'
    package: 'metaL'
\end{verbatim}

\verb|type| тег типа/класса, для читаемости имя класса в нижнем регистре и без лидирующей буквы (в Pharo не завезли namespace, приходится использовать префикс чтобы не перекрывать стандартные и системные имена классов)

\verb|val| скаляр, имя класса, или одиночное значение строки, числа, и т.п.

\verb|slot{}| словарь связывает имя слота с следующим фреймом через ссылку (ребра гиперграфа)

\verb|nest[]| упорядоченный контейнер из ссылок на другие фреймы, тоже ребра графа но упорядоченные (типа операндов оператора деления)

\fig{minsky.png}

\clearpage

\begin{verbatim}
MFrame class >> install
    type := 'frame'

MFrame >> initialize: aVal
    val := aVal.
    slot := Dictionary new.
    nest := OrderedCollection new.
    ^ self
\end{verbatim}

\clearpage

Остальные классы наследуем, добавляя дополнительные поля по вкусу и необходимости.

Для генерации embedded C выделяем отдельное дерево классов, которое умеет писать себя в ANSI C'89

\begin{verbatim}
MFrame subclass: #C89
    instanceVariableNames: ''
    classVariableNames: 'main'
    package: 'metaL'

C89 class >> install
    type := 'c89'.
    CFn install.
    main := CFn initialize: #main.
\end{verbatim}

\clearpage

Чего нет (?) в Smalltalk из коробки, и что необходимо реализовать самим:

\subsecly{парсер Си}

Ну как-бы удобнее вводить готовые куски кода (сниппеты) простым копированием, преобразовывать их в граф автоматически, сохранять в системе под значащем для вас именем, и потом уже использовать через операции трансформации.

\subsecly{структурный pattern matching на графах в стиле языка Пролог (с унификацией)}

Задаем паттерн как кусок графа, узлы которого являются переменными, условиями и операциями. Применяем его к графу над которым хотим выполнить преобразование (мутабельное или создающее измененную копию), унификатор "прикладывает" шаблон к графу (рекурсивно), в случае выполнения узлов-условий переменные биндятся на значения из графа, и выполняются узлы-преобразования. Процесс рекурсивный и с backtrackingом, если на каком-то шаге трансформация попадает в ошибку, трансформация откатывается на шаг назад.

\subsecly{система вывода и проверки типов, оптимизации и другие фишки из Dragon/Tiger Book}

Не спускаемся слишком низко по уровню, не закапываемся в сложности — это этого есть внешний backend-компилятор C++, Rust, Java,... который пилили последние 20+ лет лучшие спецы планеты, наша задача — сформировать человеко-читаемый исходный код, и передать ответственность.

\clearpage

\subsecly{}библиотека стандартных структур данных и алгоритмов

Очень большая часть может быть реализована на типовых решениях, от контейнеров и генериков, до алгоритмов и шаблонов проектирования. Фреймы рекламируются Мински как универсальный формат представления данных в ИИ, на практике мало кто проверял. На первый взгляд фреймовые гиперграфы кажутся перспективными — посмотрите на ближайшую доску для совещаний, 95% типичные графы, с узлами тип которых указан через графическую форму (условные обозначения, цвет), надписи и цвет стрелок — атрибутированные ребра.

\subsecly{}библиотеки сниппетов кода и трансформаторов

Естественно, реализуете в зависимости от того, в какой области работаете, разбавляете специализированными алгоритмами, и привязками к любым внешним библиотекам.

\clearpage

у меня основной интерес — встраиваемые системы и IoT

Очень хочется реализовать модель акторов (вычисления на асинхронных сообщениях без гарантии доставки) для программирования распределенных систем в целов

https://medium.com/@arturarsalanov/модель-акторов-e2d..

особенно вот это видео:

https://www.youtube.com/watch?v=7erJ1DV_Tlo

и классическая книга по модели и реализации:

\cite{agha}
Agha, Gul Abdulnabi
ACTORS: A Model of Concurrent Computation in Distributed Systems
MIT Press, 1985
AITR-844 https://dspace.mit.edu/bitstream/handle/1721.1/6952/A..

