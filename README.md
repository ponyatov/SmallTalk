# Smalltalk
notes on Smalltalk (in Russian)

Про вашу статью о языке

Сам занимаюсь чем-то подобным в плане применимости, https://github.com/ponyatov/Smalltalk/releases/latest

Как там в комментах, "продать" новый язык почти невозможно, когда ему конкуренцию составляют Java, Python, Haskell...

Но кажется я нащщупал метод, в чем то похожий на Model Driven Development но без идиотизма OMG/UML:
<ul>
	<li>берем любой язык, в вашем случае ваш или haskel, я взял Smalltalk/Pharo как рабочую платформу</li>
	<li>пишем на нем интерпретатор структур данных, в которых выражена модель программы которую мы хотим получить</li>
	<li>отлаживаемся используя интерпретатор</li>
	<li>готовую отлаженную модеть прогоняем через транспилер, который трансформирует модель в исходный код на одном из mainstream языков (желательно у которого пожещще с типами, типа Rust, или в вашем случае Haskel)</li>
</ul>

В результате -- пишем на удобном языке, получаем программу на "продаваемом" mainstream языке (С++).
Никакого геморроя с библиотеками и любой другой интеграцией -- добалили выхлоп транслятора моделей в проект, все, можно компилить бесшовно

Вторым глазом посматриваю на полную смену парадигмы программирования -- полный переход на модель программирования в акторах: если впилиться сейчас, еще остаются какие-то шансы взлететь на волне, когда
до людей наконец дойдет, что в современных распределенных ненадежных системах только акторное программирование может работать на верхнем уровне (интернет, облачные платформы, IoT, мобильные системы и т.п.)


https://vk.com/topic-190100763_40901648


В интервью с Alan Kay https://queue.acm.org/detail.cfm?id=1039523 есть интересная мысль: не нужно гнаться за mainstream, потому что mainstream может воспринимать только "слабые" идеи, и фильтрует "сильные". Более того, не система программирования должна следовать за аппаратной архитектурой компьютера, а наоборот — берите "сильную" идею, используйте ее как свое секретное оружие, и "железо" последует за вами в случае глобального успеха (в случае FPGA — вы сами можете контролировать свое железо).

Можно посмотреть на этот принцип чуть шире. Наш заказчик или работодатель требует чтобы мы разрабатывали программные (и аппаратные) системы только с использованием mainstream инструментов и языков, чтобы обеспечить поддержку кода, совместимость с коллегами, совместимость с типовыми инструментами. Чаще всего допустимый стек технологий задан жестко и однозначно, не важно что это — 1С, Java/Spring, JS/Node, embedded C для одного единственно допустимого компилятора, или что-то еще.

Мы бы хотели наоборот использовать удобные или интересные для нас самих инструменты и языки.

https://ru.wikipedia.org/wiki/Гомоиконичность

Мы можем добавить еще один слой косвенности — работать с программой на любом языке программирования как со структурой данных. Можно заменить исходный код в текстовых файлах на исполняемую структур данных (EDS), которая является представлением программы. Работать с такой структурой мы можем на любом другом удобном для нас языке — Smalltalk, Haskell, Python, Picat,..

Фактически, мы можем программировать на Smalltalk на любом языке — в любой момент EDS-структура или ее часть может быть выгружена из среды разработки как набор ASCII файлов на диск, и синхронизирована с Git, Visual Studio, скомпилирована и загружена в виде прошивки в железку, запущена в отладчике и т.п. И одновременно мы имеем полный доступ к этой структуре, и можем не только ее преобразовывать, но и исполнять и отлаживать через интерпретацию.



