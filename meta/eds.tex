\clearpage
\secrel{метод EDS: исполняемые структуры данных}\label{eds}

\term{EDS}: Executable Data Structure\ --- метод програмирования, который позволяет обойти
ограничения языка програмирования, который вы используете, за счет \emph{интерпретации структур данных}
как программ.

\term{Гомоикон\'{и}чность} (гомоиконность, англ. homoiconicity, homoiconic)\ --- 
свойство некоторых языков программирования, в которых структура программы похожа 
на его синтаксис, и поэтому внутреннее представление программы имеет такую же структуру, как её 
исходный код (то есть AST и синтаксис являются изоморфными).

Применение EDS позволяет не только затащить в любой язык произвольную парадигму программирования,
модель в терминах которой программист может формулировать обработку данных, но и некоторые мощные
вещи доступные только в гомоиконичных языках\note{Lisp, Scheme}: метапрограммирование, самопреобразования программ
во время исполнения (в рантайме), автоматических синтез кода по исходным данным, и т.п.
В результате мы получаем гибкость в подходах и форматах хранения программ, ценой определенной потери
вычислительной эффективности и памяти.

В качестве примера можно привести IoT\note{Интернет вещей}, в котором применяются очень маломощные
компьютеры типа микроконтроллеров Cortex-M0 с не более чем 20К ОЗУ, и десятками Кб памяти программ.
Если нам требуется обеспечить замену программного обеспечения, можно вместо прошивки в машинном коде,
обычно написанной на \ci, применить \term{интерпретацию байт-кода}, и стековую виртуальную машину.
При правильном выборе формата команд ВМ код программ оказыватся значительно компактнее машинного кода,
и мы можем не только съэкономить на объеме передаваемой прошивки, но получить дополнительный
профит в виде более стабильной работы системы (изоляция аппаратуры от программ пользователей, отсутствие
возможности "окрипичивания" при загрузке байт-кода в ОЗУ, контроль доступа к ресурсам,
конкурентное выполнение и т.п.).

В отличие от байткода\note{традиционное внутреннее представление программ в большинстве интерпретаторов,
в том числе и Java, и сам \st}, при применении EDS необязательно использовать специализированный
компилятор\ --- если язык X на котором вы пишете \term{EDS-интерпретатор} достаточно гибок, вы можете
описать программу на X, и вкомпилировать ее в исполняемый файл.

Стоит заметить, что EDS не предполагает существование исходного кода в виде текстовых файлов,
и реализацию какого-то специализированного языка программирования для их загрузки\ --- \textit{исполняемая
структура данных сама по себе является собственным "исходным кодом"}. \term{Парсер} это опция, и вы можете
ее использовать по собственному усмотрению, или наоборот полностью отказаться от текстового программирования,
и применять средства GUI, и самомодификацию программ.

Конкретную форму исполняемой структуры и архитектуру \term{виртуальной машины} вы тоже выбираете по собственному
усморению, в зависимости от требований, задачи, и предпочтений:
\begin{description}
    \item{\emph{байт-код}}\ классика, но с точки зрения методики EDS наихудший вариант: слишком низкоуровневое
    представление, фактически это машинный код ВМ, его неудобно генерировать, а больше всего\ --- проблемно
    модифицировать.
    \item{\emph{стек + словарь + массивы}}\ если некоторый язык позволяет работать с
    гетерогенными\note{хранить объекты разных или произвольных классов, например Python}
    структурами данных и хранить в них функции, на нем очень легко пишется интерпретатор языка Форт:
    программа этомассив данных и функций
    \item{\emph{вложенные и рекурсивные списки}}\ классика в квадрате, с легким привкусом антиквариата\ --- Lisp полностью
    определен как операции на исполняемых списках; недостаток: все есть список, поэтому другие структуры тоже приходится
    определять через список
    \item{\emph{AST, граф объектов}}\ самый высокоуровневый вариант, применяется
    нечасто\note{язык Пролог (?), и экспериментальные языки построенные на перезаписи графов} так как
    их интерпретация считается слишком медленной для вычислений и обработки данных,
    но если ориентироваться на метапрограммирование и преобразования программ, наоборот подходит больше всего
    \item{\emph{реляционная база данных}}\ ну, эээ... наверно возможно, но сложно представить как, а главное зачем
    (если не рассматривать сериализацию программ и хранимые процедуры интерпретирующие интерпретатор)
\end{description}